# Load libraries
library(readxl)
library(tidyr)
library(dplyr)
library(writexl)
library(broom)

# Set your working directory
setwd("/Volumes/Elements/")  # Adjust if needed

# Load your data
data <- read_excel("All_Triplicate_Ct_Stats.xlsx")
colnames(data) <- make.names(colnames(data))  # Clean column names

# Function to run repeated-measures ANOVA + post hoc tests
run_rm_anova <- function(sample_name, output_file) {
  # Reshape data to long format
  df <- data %>%
    dplyr::filter(Sample == sample_name) %>%
    dplyr::select(Target.Gene, starts_with("Replicate")) %>%
    tidyr::pivot_longer(cols = starts_with("Replicate"),
                        names_to = "Replicate",
                        values_to = "Ct") %>%
    dplyr::mutate(Subject = factor(Replicate),
                  Target.Gene = factor(Target.Gene))
  
  # Run repeated-measures ANOVA
  model <- aov(Ct ~ Target.Gene + Error(Subject/Target.Gene), data = df)
  cat("### Repeated-Measures ANOVA for", sample_name, "###\n")
  print(summary(model))
  
  # Post hoc paired t-tests with Bonferroni correction
  genes <- unique(df$Target.Gene)
  combos <- combn(genes, 2, simplify = FALSE)
  posthoc <- data.frame(Gene1 = character(), Gene2 = character(),
                        t = numeric(), p = numeric(), stringsAsFactors = FALSE)
  for (pair in combos) {
    x <- dplyr::filter(df, Target.Gene == pair[1]) %>%
      dplyr::arrange(Subject) %>% dplyr::pull(Ct)
    y <- dplyr::filter(df, Target.Gene == pair[2]) %>%
      dplyr::arrange(Subject) %>% dplyr::pull(Ct)
    t_result <- t.test(x, y, paired = TRUE)
    posthoc <- rbind(posthoc, data.frame(
      Gene1 = pair[1],
      Gene2 = pair[2],
      t = as.numeric(t_result$statistic),
      p = as.numeric(t_result$p.value)
    ))
  }
  posthoc$p_bonf <- p.adjust(posthoc$p, method = "bonferroni")
  print(posthoc)
  
  # Save to Excel
  write_xlsx(list(
    "ANOVA Summary" = broom::tidy(summary(model)),
    "Post Hoc Tests" = posthoc
  ), output_file)
}


# Run for A CDNA
run_rm_anova("A CDNA", "A_CDna_RM_ANOVA.xlsx")

# Function to run repeated-measures ANOVA + post hoc tests on Sample B
run_rm_anova <- function(sample_name, output_file) {
  # Reshape data to long format
  df <- data %>%
    dplyr::filter(Sample == sample_name) %>%
    dplyr::select(Target.Gene, starts_with("Replicate")) %>%
    tidyr::pivot_longer(cols = starts_with("Replicate"),
                        names_to = "Replicate",
                        values_to = "Ct") %>%
    dplyr::mutate(Subject = factor(Replicate),
                  Target.Gene = factor(Target.Gene))
  
  # Run repeated-measures ANOVA
  model <- aov(Ct ~ Target.Gene + Error(Subject/Target.Gene), data = df)
  cat("### Repeated-Measures ANOVA for", sample_name, "###\n")
  print(summary(model))
  
  # Post hoc paired t-tests with Bonferroni correction
  genes <- unique(df$Target.Gene)
  combos <- combn(genes, 2, simplify = FALSE)
  posthoc <- data.frame(Gene1 = character(), Gene2 = character(),
                        t = numeric(), p = numeric(), stringsAsFactors = FALSE)
  for (pair in combos) {
    x <- dplyr::filter(df, Target.Gene == pair[1]) %>%
      dplyr::arrange(Subject) %>% dplyr::pull(Ct)
    y <- dplyr::filter(df, Target.Gene == pair[2]) %>%
      dplyr::arrange(Subject) %>% dplyr::pull(Ct)
    t_result <- t.test(x, y, paired = TRUE)
    posthoc <- rbind(posthoc, data.frame(
      Gene1 = pair[1],
      Gene2 = pair[2],
      t = as.numeric(t_result$statistic),
      p = as.numeric(t_result$p.value)
    ))
  }
  posthoc$p_bonf <- p.adjust(posthoc$p, method = "bonferroni")
  print(posthoc)
  
  # Save output
  anova_txt_path <- gsub(".xlsx", "_ANOVA.txt", output_file)
  sink(anova_txt_path)
  cat("Repeated-Measures ANOVA for", sample_name, "\n")
  print(summary(model))
  sink()
  
  write_xlsx(list(
    "Post Hoc Tests" = posthoc
  ), output_file)
}

# Run the function for B CDNA
run_rm_anova("B CDNA", "B_CDna_RM_ANOVA.xlsx")

# testing for normality ----

# Load required libraries
library(readxl)
library(dplyr)
library(tidyr)

# Load your data
data <- read_excel("All_Triplicate_Ct_Stats.xlsx")
colnames(data) <- make.names(colnames(data))  # Clean column names

# Function to run repeated-measures ANOVA and check residual normality
check_normality <- function(sample_name) {
  # Prepare long-format data
  df <- data %>%
    dplyr::filter(Sample == sample_name) %>%
    dplyr::select(Target.Gene, starts_with("Replicate")) %>%
    tidyr::pivot_longer(cols = starts_with("Replicate"),
                        names_to = "Replicate",
                        values_to = "Ct") %>%
    dplyr::mutate(
      Subject = factor(Replicate),
      Target.Gene = factor(Target.Gene)
    ) %>%
    # Remove any NA values that might cause issues
    dplyr::filter(!is.na(Ct))
  
  # Check if we have enough data
  if(nrow(df) < 3) {
    cat("Not enough data for", sample_name, "\n")
    return(NULL)
  }
  
  # Run repeated-measures ANOVA
  model <- aov(Ct ~ Target.Gene + Error(Subject/Target.Gene), data = df)
  
  # Extract residuals properly
  # Method 1: Try to get residuals from the Within component
  if("Within" %in% names(model) && !is.null(model[["Within"]]$residuals)) {
    residuals_vec <- as.numeric(model[["Within"]]$residuals)
    residuals_vec <- residuals_vec[!is.na(residuals_vec)]
  } else {
    # Method 2: Alternative approach using a simpler model
    simple_model <- aov(Ct ~ Target.Gene, data = df)
    residuals_vec <- as.numeric(residuals(simple_model))
    residuals_vec <- residuals_vec[!is.na(residuals_vec)]
  }
  
  # Check if we have valid residuals
  if(length(residuals_vec) < 3) {
    cat("Not enough residuals for normality test for", sample_name, "\n")
    return(NULL)
  }
  
  # Shapiro-Wilk normality test
  cat("Shapiro-Wilk test for", sample_name, "residuals:\n")
  cat("Number of residuals:", length(residuals_vec), "\n")
  print(shapiro.test(residuals_vec))
  cat("\n---------------------------\n")
  
  # Optional: return the residuals for further analysis
  return(residuals_vec)
}

# Run for both samples
residuals_A <- check_normality("A CDNA")
residuals_B <- check_normality("B CDNA")


